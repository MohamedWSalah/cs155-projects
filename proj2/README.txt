# Part 2: Defenses

## Attack Alpha
Attack Alpha relies on unsanatized user input being rendered to the page. We can avoid this attack (and other similar attacks), by simply sanatizing the user input by escaping all HTML related characters in any input provided by the user. While somewhat excessive, this is the easiest and most straight-forward way of knowing that the input is safe. Alternatively, we could keep a whitelist of allowed tags (such as <p>), but we'd rather err on the side of security. We make sure everything is sanatized by changing the render() function to sanatize values before passing them to the EJS templates. We also make sure we sanitize the result/account.profile and result/account.username, which are both properties that are often displayed on the page. We would sanitize the session further (such as bitbars field), but given the other security measures we've implemented, it's not possible for the client to tamper with the cookie and we don't provide a mechanism for changing any other values.

## Attack Bravo
Attack Bravo relies on Cross-Site Request Forgery. The most straight forward way to solve this problem is to embed a secret token into the transfer page which depends on the logged in user in some way. This token should be difficult to guess. We can satisfy these requirements by simply using the HMAC function in the crypto.js library to generate a signature on the user + hashedpassword + salt data in the session (which should not change per session). The server is the only one able to generate this signature, and an attacker will be unable to guess it. This token allows us to verify the POST request is authorized by the user, since we include the token as part of the request. We do something similar for the set_profile API, and thereby prevent CSRF attacks there too. Essentially, for any form we present to the user, we embed a secret token. Generating the secret token is essentially impossible for the attacker, and requesting a page from the server that will generate the same token will require (1) modifying the session cookie and (2) correctly guessing another user's password. Not only is (2) extremely difficult, but even if an attacker could, we've added other security mechanisms to prevent an attacker from tampering with the session cookie and attempting to retrieve a token for another user.

## Attack Charlie
Attack Charlie relies mostly on the fact that all the session information is stored client-side. We can prevent client-side session attacks by signing our session with a secret, server-only key. Anytime the server starts a session, it signs the session and stores this key with the session (an attacker could see this key). Anytime the servers changes the session, it signs it again. And anytime the server reads the session, it verifies the signature before using any values from the ssion. If the signature is invalid, we immediately log the user out and inform them that they may be under attack. An attacker has no reasonable method of tampering with the session cookie since any change will invalidate the associated signature. Note that while this mechanism defends against tampering, it does not defend against replay attacks.

## Attack Delta
This attack similary relies on the ability to overwrite the local cookie. We prevent it by signing the cookie and checking the signature before making any transactions. We update all of the site code to always verify the cookie before performing any actions based on the contents of the session.

## Attack Echo
The easiest protection against a SQL Injection attack is to simply disallow any non alphanumeric characters. We implement this for the user field, as it does not make sense to allow users to use non alphanumeric characters in their usernames. However, we also update all of our SQL queries to make use of prepared statements, rather than string concatenation and replacement. In this way, it becomes impossible for any of our SQL statements to be injected with malicious SQL, since the input from the user will never be parsed as part of the semantic meaning of the SQL.

## Attack Foxtrot
We handle this attack by always sanitizing the input so we escape all HTML characters. Furthermore, with the additional verifications added to the set_profile route (we verify the user token), it makes the attack even more difficult to accomplish (the attacker would have to remmeber to grab the secret token).